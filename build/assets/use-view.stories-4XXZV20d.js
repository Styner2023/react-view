import{j as o,g as kt}from"./index-OfupEra9.js";import{u as ge,P as ue,L as We,H as He,a as Y,C as ve,b as vt,E as pe,K as xt,c as xe,A as Je,h as Ee,i as de,I as Q,j as Ae,r as Ve,k as Ze,m as Me,n as oe,o as Et,p as Pt,q as _t,s as $t,v as Dt,w as Xe,x as Ot,y as Rt,z as Bt}from"./action-buttons-1xy8bqUX.js";import{S as Le,B as Ke}from"./button-Fm_AxZIp.js";const Ft=()=>{const e=ge({componentName:"Button",props:{children:{value:"Hello",type:ue.ReactNode,description:"Visible label."},size:{value:"SIZE.default",defaultValue:"SIZE.default",options:Le,type:ue.Enum,description:"Defines the size of the button.",imports:{"your-button-component":{named:["SIZE"]}}},onClick:{value:'() => alert("click")',type:ue.Function,description:"Function called when button is clicked."},disabled:{value:!1,type:ue.Boolean,description:"Indicates that the button is disabled"}},scope:{Button:Ke,SIZE:Le},imports:{"your-button-component":{named:["Button"]}}});return o.jsxs(We,{children:[o.jsx(He,{children:"Basic example of useView"}),o.jsxs(Y,{children:["This is our main"," ",o.jsx("a",{href:"https://reactjs.org/docs/hooks-intro.html",children:"hook"})," based API. React View strictly separates the UI components from everything else so you can completely customize every aspect of the playground. If you want to start as quickly as possible, try the"," ",o.jsx("a",{href:"/?path=/story/view--view",children:"View component"})," instead."]}),o.jsx(ve,{...e.compilerProps,minHeight:62,placeholder:vt}),o.jsx(pe,{msg:e.errorProps.msg,isPopup:!0}),o.jsx(xt,{...e.knobProps}),o.jsx(xe,{...e.editorProps,"data-testid":"rv-editor"}),o.jsx(pe,{...e.errorProps}),o.jsx(Je,{...e.actions}),o.jsxs(Y,{children:["This is a basic example that demonstrates all basic features of React View. At the top, you can see the ",o.jsx("b",{children:"rendered component"}),", followed by the ",o.jsx("b",{children:"middle section with knobs"})," that lets you explore all component props, the ",o.jsx("b",{children:"edittable code snippet"})," and finally some"," ",o.jsx("b",{children:"action buttons"}),"."]}),o.jsx(Ee,{children:"Usage"}),o.jsx(de,{children:`import * as React from 'react';
import {Button, SIZE} from 'your-button-component';

import {
  useView,
  Compiler,
  Knobs,
  Editor,
  Error,
  ActionButtons,
  Placeholder,
  PropTypes,
} from 'react-view';

const Basic = () => {
  const params = useView({
    componentName: 'Button',
    props: {
      children: {
        value: 'Hello',
        type: PropTypes.ReactNode,
        description: 'Visible label.',
      },
      size: {
        value: 'SIZE.default',
        defaultValue: 'SIZE.default',
        options: SIZE,
        type: PropTypes.Enum,
        description: 'Defines the size of the button.',
        imports: {
          'your-button-component': {
            named: ['SIZE'],
          },
        },
      },
      onClick: {
        value: '() => alert("click")',
        type: PropTypes.Function,
        description: 'Function called when button is clicked.',
      },
      disabled: {
        value: false,
        type: PropTypes.Boolean,
        description: 'Indicates that the button is disabled',
      },
    },
    scope: {
      Button,
      SIZE,
    },
    imports: {
      'your-button-component': {
        named: ['Button'],
      },
    },
  });

  return (
    <React.Fragment>
      <Compiler {...params.compilerProps} minHeight={62} placeholder={Placeholder} />
      <Error msg={params.errorProps.msg} isPopup />
      <Knobs {...params.knobProps} />
      <Editor {...params.editorProps} />
      <Error {...params.errorProps} />
      <ActionButtons {...params.actions} />
    </React.Fragment>
  );
}
`}),o.jsxs(Y,{children:[o.jsx("b",{children:"useView"})," expects a configuration describing your component and returns a data-structure that nicely fits into multiple UI components such as Compiler, Error, Knobs, Editor and Action Buttons. That gives you the maximum flexibility since you can swap any of these components for your own."]}),o.jsx(Y,{children:o.jsx("b",{children:"Note that you never have to specify the code snippet since the code is auto-generated based on the rest of useView configuration and internal state."})}),o.jsxs(Y,{children:["The biggest part of configuration is a list of ",o.jsx(Q,{children:"props"}),". You also have to explicitly define the ",o.jsx(Q,{children:"scope"})," (in this case, importing the Button and passing it through). On the other hand, the ",o.jsx(Q,{children:"imports"})," setting is completely optional. The imports appear at the top of auto-generated code. That can be nice for your users since they will be always able to copy paste a fully working example."," "]})]})},At=Ft,qe={default:"default",compact:"compact",large:"large"},Mt=({value:e,onChange:L,size:C,disabled:j,editable:w})=>{const F={...(v=>{switch(v){case qe.compact:return{padding:"8px",fontSize:"14px"};case qe.large:return{padding:"18px",fontSize:"20px"};default:return{padding:"12px",fontSize:"16px"}}})(C),background:j?"#BBB":"#FFF",color:"#000",borderRadius:"5px",borderWidth:"2px",borderStyle:"solid",borderColor:"#000"};return o.jsx("input",{id:"example-input",value:e,onChange:L,style:F,disabled:!(typeof w>"u"||w)})},Lt=()=>{const e=ge({componentName:"Input",props:{value:{value:"Hello",type:ue.String,description:"Input value.",stateful:!0},size:{value:"SIZE.default",defaultValue:"SIZE.default",options:qe,type:ue.Enum,description:"Defines the size of the button.",imports:{"your-input-component":{named:["SIZE"]}}},onChange:{value:"e => setValue(e.target.value)",type:ue.Function,description:"Function called when input value is changed.",propHook:{what:"e.target.value",into:"value"}},editable:{value:!0,defaultValue:!0,type:ue.Boolean,description:"Indicates that the input is editable."}},scope:{Input:Mt,SIZE:qe},imports:{"your-input-component":{named:["Input"]}}});return o.jsxs(We,{children:[o.jsx(He,{children:"State Hook"}),o.jsxs(Y,{children:["Not all components are as simple as buttons. The most of React components have some sort of state. For example, inputs have the"," ",o.jsx("b",{children:"value"})," state. By default, React View treats everything as"," ",o.jsx("a",{href:"https://reactjs.org/docs/forms.html#controlled-components",children:"controlled components"}),". So when you specify the list of props in useView, you will get the output like this:"]}),o.jsx(de,{children:`<Input value="Hello" onChange={console.log} />
`}),o.jsxs(Y,{children:["And that works. You can still update the value by changing the value knob or editing the code directly."," ",o.jsx("b",{children:"However, you would not be able to interact with the component itself"})," ","since the value is hard-coded - the component is controlled. The code above is also not very realistic. How often do we create non editable inputs?"]}),o.jsxs(Y,{children:["Fortunately, React View has special"," ",o.jsx("b",{children:o.jsx(Q,{children:"propHook"})})," ","and"," ",o.jsx("b",{children:o.jsx(Q,{children:"stateful"})})," ","settings so you can achieve full interactivity:"]}),o.jsx(ve,{...e.compilerProps,minHeight:62,placeholder:vt}),o.jsx(pe,{msg:e.errorProps.msg,isPopup:!0}),o.jsx(xt,{...e.knobProps}),o.jsx(xe,{...e.editorProps,"data-testid":"rv-editor"}),o.jsx(pe,{...e.errorProps}),o.jsx(Je,{...e.actions}),o.jsxs(Y,{children:["The example above has its ",o.jsx("b",{children:"own internal value state"})," (using"," ",o.jsx("a",{href:"https://reactjs.org/docs/hooks-reference.html#usestate",children:"React.useState"}),") and the value knob is now translated into its initial internal state. Now you can interact with the component itself and"," ",o.jsx("b",{children:"everything is still synchronized"}),". Moreover, the code snippet now also better demonstrates the real-world usage."]}),o.jsx(Ee,{children:"Usage"}),o.jsx(de,{children:`import * as React from 'react';
import {Input, SIZE} from 'your-input-component';

import {
  useView,
  Compiler,
  Knobs,
  Editor,
  Error,
  ActionButtons,
  Placeholder,
  PropTypes,
} from 'react-view';

const StateHook = () => {
  const params = useView({
    componentName: 'Input',
    props: {
      value: {
        value: 'Hello',
        type: PropTypes.String,
        description: 'Input value.',
        stateful: true,
      },
      size: {
        value: 'SIZE.default',
        defaultValue: 'SIZE.default',
        options: SIZE,
        type: PropTypes.Enum,
        description: 'Defines the size of the button.',
        imports: {
          'your-input-component': {
            named: ['SIZE'],
          },
        },
      },
      onChange: {
        value: 'e => setValue(e.target.value)',
        type: PropTypes.Function,
        description: 'Function called when input value is changed.',
        propHook: {
          what: 'e.target.value',
          into: 'value',
        },
      },
      editable: {
        value: true,
        defaultValue: true,
        type: PropTypes.Boolean,
        description: 'Indicates that the input is editable.',
      },
    },
    scope: {
      Input,
      SIZE,
    },
    imports: {
      'your-input-component': {
        named: ['Input'],
      },
    },
  });

  return (
    <React.Fragment>
      <Compiler {...params.compilerProps} minHeight={62} placeholder={Placeholder} />
      <Error msg={params.errorProps.msg} isPopup />
      <Knobs {...params.knobProps} />
      <Editor {...params.editorProps} />
      <Error {...params.errorProps} />
      <ActionButtons {...params.actions} />
    </React.Fragment>
  );
};`}),o.jsxs(Y,{children:["There are just two changes that we have to make compared to the"," ",o.jsx("a",{href:"/?path=/story/useview--basic",children:"basic example"}),". First, we have to detach the value prop into an internal state. We simply add the"," ",o.jsxs("b",{children:[o.jsx(Q,{children:"stateful"})," flag"]}),":"]}),o.jsx(de,{children:`useView({
  props: {
    value: {
      value: 'Hello',
      type: PropTypes.String,
      stateful: true,
    },
  /* ... */
  }
})
`}),o.jsxs(Y,{children:["At this point,"," ",o.jsx("b",{children:"the value is detached and rendered input is fully interactive"}),". However, the changes are not synchronized with the rest of the playground. We need to give React View a slight hint:"," "]}),o.jsx(de,{children:`onChange: {
  value: 'e => setValue(e.target.value)',
  type: PropTypes.Function,
  propHook: {
    what: 'e.target.value',
    into: 'value',
  },
}
`}),o.jsxs(Y,{children:["We have added the"," ",o.jsx("b",{children:o.jsx(Q,{children:"propHook.what"})})," ","and"," ",o.jsx("b",{children:o.jsx(Q,{children:"propHook.into"})})," ","in the ",o.jsx(Q,{children:"onChange"})," prop. We are telling React View"," ",o.jsx(Q,{children:"what"})," value it should use and ",o.jsx(Q,{children:"into"})," what stateful prop it should go. Note that this setting also depends on the initial value of ",o.jsx(Q,{children:"onChange"})," prop since React View secretly adds an instrumentation call into the body of"," ",o.jsx(Q,{children:"e > setValue(e.target.value)"})," function."]}),o.jsx(Ee,{children:"defaultValue"}),o.jsxs(Y,{children:["Props can have a ",o.jsx(Q,{children:"defaultValue"}),". That is useful for an"," ",o.jsx(Q,{children:"enum"})," so the code generator knows when to skip the default option. Sometimes you can also have a ",o.jsx(Q,{children:"boolean"})," ","prop that treats ",o.jsx(Q,{children:"undefined"})," the opposite way to"," ",o.jsx(Q,{children:"false"}),". In the example above, this inverted behavior is demonstrated with the prop ",o.jsx(Q,{children:"editable"}),":"]}),o.jsx(de,{children:`editable: {
  value: true,
  defaultValue: true,
  type: PropTypes.Boolean,
  description: 'Indicates that the input is editable.',
}`})]})},qt=Lt,Wt=`export default () => {
  return (
    <Button onClick={() => alert("click")}>Hello</Button>
  );
}`,Ht='<Button onClick={() => alert("click")}>Hello</Button>',Vt="2 + 5",Ut=()=>{const e=ge({initialCode:Wt,scope:{Button:Ke,SIZE:Le}}),L=ge({initialCode:Ht,scope:{Button:Ke,SIZE:Le}}),C=ge({initialCode:Vt});return o.jsxs(We,{children:[o.jsx(He,{children:"Live Code Editor"}),o.jsxs(Y,{children:["The useView hook can be also used as a live editor only (no prop knobs or code generation). In this mode, it is very similar to"," ",o.jsx("a",{href:"https://github.com/FormidableLabs/react-live",children:"react-live"}),"."," "]}),o.jsx(Ae,{children:o.jsx(ve,{...e.compilerProps})}),o.jsx(xe,{...e.editorProps}),o.jsx(pe,{...e.errorProps}),o.jsx(Y,{children:"You can create your UI or re-use components from react-view (Editor, Error...). Optionally you can also add the action buttons:"}),o.jsx(Je,{...e.actions}),o.jsxs(Y,{children:[o.jsx("b",{children:"This time you do not need to configure a list of props"}),". There are no knobs. However, since no code is auto-generated, you should probably set the ",o.jsx(Q,{children:"intialCode"})," so the user sees something besides an empty box."]}),o.jsx(Ee,{children:"Usage"}),o.jsx(de,{children:`import {
  useView,
  Compiler,
  Editor,
  Error,
  ActionButtons
} from 'react-view';

export default () => {
  const params = useView({
    initialCode: '<Button>Hello</Button>',
    scope: {Button: ({children}) => <button>{children}</button>},
    onUpdate: console.log
  });

  return (
    <React.Fragment>
      <Compiler {...params.compilerProps} />
      <Editor {...params.editorProps} />
      <Error {...params.errorProps} />
      <ActionButtons {...params.actions} />
    </React.Fragment>
  );
}`}),o.jsxs(Y,{children:[o.jsx("b",{children:"Note:"})," All import statements in the editor are always taken out before compilation. ",o.jsx("b",{children:"They do not do anything."})," Our compiler does not understand modules (we do not have a bundler in our flow). So feel free to add them if beneficial for your users. All dependencies need to be passed through the ",o.jsx(Q,{children:"scope"})," prop (React is included automatically)."]}),o.jsx(Ee,{children:"Accepted Code"}),o.jsxs(Y,{children:["The compiler can also handle a ",o.jsx("b",{children:"React element"})," or class (but we do not really use those anymore, do we?)."]}),o.jsx(Ae,{children:o.jsx(ve,{...L.compilerProps})}),o.jsx(xe,{...L.editorProps}),o.jsx(pe,{...L.errorProps}),o.jsxs(Y,{children:["...or pretty much anything that"," ",o.jsxs("b",{children:["could be executed after the ",o.jsx(Q,{children:"return"})," statement of JS function."]})]}),o.jsx(Ae,{children:o.jsx(ve,{...C.compilerProps})}),o.jsx(xe,{...C.editorProps}),o.jsx(pe,{...C.errorProps})]})},zt=Ut;var _e={},we={},je={},Ye;function Gt(){if(Ye)return je;Ye=1,Object.defineProperty(je,"__esModule",{value:!0}),je.default=void 0;var e=Ve(),L=function(C,j){const w=[];C.forEach((S,F)=>{(Array.isArray(S)?S[0]:S)===j&&w.unshift(F)});for(const S of w)C.splice(S,1)};return je.default=(0,e.declare)((C,j)=>{C.assertVersion(7);const{disallowAmbiguousJSXLike:w,dts:S}=j;var{isTSX:F}=j;return{name:"syntax-typescript",manipulateOptions(v,d){{const{plugins:g}=d;L(g,"flow"),L(g,"jsx"),g.push("objectRestSpread","classProperties"),F&&g.push("jsx")}d.plugins.push(["typescript",{disallowAmbiguousJSXLike:w,dts:S}])}}}),je}var ze={},le={},fe={},$e={},Qe;function St(){if(Qe)return $e;Qe=1,Object.defineProperty($e,"__esModule",{value:!0});var e=Ze();function L(p){if(p&&p.__esModule)return p;var O=Object.create(null);return p&&Object.keys(p).forEach(function(N){if(N!=="default"){var k=Object.getOwnPropertyDescriptor(p,N);Object.defineProperty(O,N,k.get?k:{enumerable:!0,get:function(){return p[N]}})}}),O.default=p,Object.freeze(O)}var C=L(e);function j(p){const O=p,{node:N,parentPath:k}=O;if(k.isLogicalExpression()){const{operator:B,right:t}=k.node;if(B==="&&"||B==="||"||B==="??"&&N===t)return j(k)}if(k.isSequenceExpression()){const{expressions:B}=k.node;return B[B.length-1]===N?j(k):!0}return k.isConditional({test:N})||k.isUnaryExpression({operator:"!"})||k.isLoop({test:N})}const{LOGICAL_OPERATORS:w,arrowFunctionExpression:S,assignmentExpression:F,binaryExpression:v,booleanLiteral:d,callExpression:g,cloneNode:m,conditionalExpression:R,identifier:i,isMemberExpression:f,isOptionalCallExpression:a,isOptionalMemberExpression:u,isUpdateExpression:I,logicalExpression:h,memberExpression:D,nullLiteral:l,optionalCallExpression:x,optionalMemberExpression:E,sequenceExpression:P,updateExpression:M}=C;class H{constructor(){this._map=void 0,this._map=new WeakMap}has(O){return this._map.has(O)}get(O){if(!this.has(O))return;const N=this._map.get(O),{value:k}=N;return N.count--,N.count===0?F("=",k,O):k}set(O,N,k){return this._map.set(O,{count:k,value:N})}}function $(p,O){const{node:N}=p;if(u(N))return D(O,N.property,N.computed);if(p.isOptionalCallExpression()){const k=p.get("callee");if(p.node.optional&&k.isOptionalMemberExpression()){const B=k.node.object,t=p.scope.maybeGenerateMemoised(B);return k.get("object").replaceWith(F("=",t,B)),g(D(O,i("call")),[t,...p.node.arguments])}return g(O,p.node.arguments)}return p.node}function q(p){for(;p&&!p.isProgram();){const{parentPath:O,container:N,listKey:k}=p,B=O.node;if(k){if(N!==B[k])return!0}else if(N!==B)return!0;p=O}return!1}const r={memoise(){},handle(p,O){const{node:N,parent:k,parentPath:B,scope:t}=p;if(p.isOptionalMemberExpression()){if(q(p))return;const s=p.find(({node:J,parent:W})=>u(W)?W.optional||W.object!==J:a(W)?J!==p.node&&W.optional||W.callee!==J:!0);if(t.path.isPattern()){s.replaceWith(g(S([],s.node),[]));return}const b=j(s),c=s.parentPath;if(c.isUpdateExpression({argument:N}))throw p.buildCodeFrameError("can't handle update expression");const y=c.isAssignmentExpression({left:s.node}),_=c.isUnaryExpression({operator:"delete"});if(_&&s.isOptionalMemberExpression()&&s.get("property").isPrivateName())throw p.buildCodeFrameError("can't delete a private class element");let T=p;for(;;){if(T.isOptionalMemberExpression()){if(T.node.optional)break;T=T.get("object");continue}else if(T.isOptionalCallExpression()){if(T.node.optional)break;T=T.get("callee");continue}throw new Error(`Internal error: unexpected ${T.node.type}`)}const V=T.isOptionalMemberExpression()?T.node.object:T.node.callee,U=t.maybeGenerateMemoised(V),K=U??V,ee=B.isOptionalCallExpression({callee:N}),Z=J=>ee,te=B.isCallExpression({callee:N});T.replaceWith($(T,K)),Z()?k.optional?B.replaceWith(this.optionalCall(p,k.arguments)):B.replaceWith(this.call(p,k.arguments)):te?p.replaceWith(this.boundGet(p)):this.delete&&B.isUnaryExpression({operator:"delete"})?B.replaceWith(this.delete(p)):B.isAssignmentExpression()?n(this,p,B):p.replaceWith(this.get(p));let G=p.node;for(let J=p;J!==s;){const W=J.parentPath;if(W===s&&Z()&&k.optional){G=W.node;break}G=$(W,G),J=W}let z;const X=s.parentPath;if(f(G)&&X.isOptionalCallExpression({callee:s.node,optional:!0})){const{object:J}=G;z=p.scope.maybeGenerateMemoised(J),z&&(G.object=F("=",z,J))}let se=s;(_||y)&&(se=X,G=X.node);const re=U?F("=",m(K),m(V)):m(K);if(b){let J;O?J=v("!=",re,l()):J=h("&&",v("!==",re,l()),v("!==",m(K),t.buildUndefinedNode())),se.replaceWith(h("&&",J,G))}else{let J;O?J=v("==",re,l()):J=h("||",v("===",re,l()),v("===",m(K),t.buildUndefinedNode())),se.replaceWith(R(J,_?d(!0):t.buildUndefinedNode(),G))}if(z){const J=X.node;X.replaceWith(x(E(J.callee,i("call"),!1,!0),[m(z),...J.arguments],!1))}return}if(I(k,{argument:N})){if(this.simpleSet){p.replaceWith(this.simpleSet(p));return}const{operator:s,prefix:b}=k;this.memoise(p,2);const c=t.generateUidIdentifierBasedOnNode(N);t.push({id:c});const y=[F("=",m(c),this.get(p))];if(b){y.push(M(s,m(c),b));const _=P(y);B.replaceWith(this.set(p,_));return}else{const _=t.generateUidIdentifierBasedOnNode(N);t.push({id:_}),y.push(F("=",m(_),M(s,m(c),b)),m(c));const T=P(y);B.replaceWith(P([this.set(p,T),m(_)]));return}}if(B.isAssignmentExpression({left:N})){n(this,p,B);return}if(B.isCallExpression({callee:N})){B.replaceWith(this.call(p,B.node.arguments));return}if(B.isOptionalCallExpression({callee:N})){if(t.path.isPattern()){B.replaceWith(g(S([],B.node),[]));return}B.replaceWith(this.optionalCall(p,B.node.arguments));return}if(this.delete&&B.isUnaryExpression({operator:"delete"})){B.replaceWith(this.delete(p));return}if(B.isForXStatement({left:N})||B.isObjectProperty({value:N})&&B.parentPath.isObjectPattern()||B.isAssignmentPattern({left:N})&&B.parentPath.isObjectProperty({value:k})&&B.parentPath.parentPath.isObjectPattern()||B.isArrayPattern()||B.isAssignmentPattern({left:N})&&B.parentPath.isArrayPattern()||B.isRestElement()){p.replaceWith(this.destructureSet(p));return}B.isTaggedTemplateExpression()?p.replaceWith(this.boundGet(p)):p.replaceWith(this.get(p))}};function n(p,O,N){if(p.simpleSet){O.replaceWith(p.simpleSet(O));return}const{operator:k,right:B}=N.node;if(k==="=")N.replaceWith(p.set(O,B));else{const t=k.slice(0,-1);w.includes(t)?(p.memoise(O,1),N.replaceWith(h(t,p.get(O),p.set(O,B)))):(p.memoise(O,2),N.replaceWith(p.set(O,v(t,p.get(O),B))))}}function A(p,O,N){p.traverse(O,Object.assign({},r,N,{memoiser:new H}))}return $e.default=A,$e}var De={},et;function wt(){if(et)return De;et=1,Object.defineProperty(De,"__esModule",{value:!0}),De.default=d;var e=Ze();const{callExpression:L,identifier:C,isIdentifier:j,isSpreadElement:w,memberExpression:S,optionalCallExpression:F,optionalMemberExpression:v}=e;function d(g,m,R,i){return R.length===1&&w(R[0])&&j(R[0].argument,{name:"arguments"})?i?F(v(g,C("apply"),!1,!0),[m,R[0].argument],!1):L(S(g,C("apply")),[m,R[0].argument]):i?F(v(g,C("call"),!1,!0),[m,...R],!1):L(S(g,C("call")),[m,...R])}return De}var tt;function jt(){if(tt)return fe;tt=1,Object.defineProperty(fe,"__esModule",{value:!0}),fe.default=void 0;var e=Me(),L=St(),C=wt(),j=oe();const{assignmentExpression:w,booleanLiteral:S,callExpression:F,cloneNode:v,identifier:d,memberExpression:g,sequenceExpression:m,stringLiteral:R,thisExpression:i}=j.types;{const l=Me();fe.environmentVisitor=l.default,fe.skipAllButComputedKey=l.skipAllButComputedKey}function f(l,x,E,P){l=v(l);const M=x||P?l:g(l,d("prototype"));return F(E.addHelper("getPrototypeOf"),[M])}const a=j.traverse.visitors.merge([e.default,{Super(l,x){const{node:E,parentPath:P}=l;P.isMemberExpression({object:E})&&x.handle(P)}}]),u=j.traverse.visitors.merge([e.default,{Scopable(l,{refName:x}){const E=l.scope.getOwnBinding(x);E&&E.identifier.name===x&&l.scope.rename(x)}}]),I={memoise(l,x){const{scope:E,node:P}=l,{computed:M,property:H}=P;if(!M)return;const $=E.maybeGenerateMemoised(H);$&&this.memoiser.set(H,$,x)},prop(l){const{computed:x,property:E}=l.node;return this.memoiser.has(E)?v(this.memoiser.get(E)):x?v(E):R(E.name)},get(l){return this._get(l,this._getThisRefs())},_get(l,x){const E=f(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return F(this.file.addHelper("get"),[x.memo?m([x.memo,E]):E,this.prop(l),x.this])},_getThisRefs(){if(!this.isDerivedConstructor)return{this:i()};const l=this.scope.generateDeclaredUidIdentifier("thisSuper");return{memo:w("=",l,i()),this:v(l)}},set(l,x){const E=this._getThisRefs(),P=f(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return F(this.file.addHelper("set"),[E.memo?m([E.memo,P]):P,this.prop(l),x,E.this,S(l.isInStrictMode())])},destructureSet(l){throw l.buildCodeFrameError("Destructuring to a super field is not supported yet.")},call(l,x){const E=this._getThisRefs();return(0,C.default)(this._get(l,E),v(E.this),x,!1)},optionalCall(l,x){const E=this._getThisRefs();return(0,C.default)(this._get(l,E),v(E.this),x,!0)},delete(l){return l.node.computed?m([F(this.file.addHelper("toPropertyKey"),[v(l.node.property)]),j.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]):j.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `}},h=Object.assign({},I,{prop(l){const{property:x}=l.node;return this.memoiser.has(x)?v(this.memoiser.get(x)):v(x)},get(l){const{isStatic:x,getSuperRef:E}=this,{computed:P}=l.node,M=this.prop(l);let H;if(x){var $;H=($=E())!=null?$:g(d("Function"),d("prototype"))}else{var q;H=g((q=E())!=null?q:d("Object"),d("prototype"))}return g(H,M,P)},set(l,x){const{computed:E}=l.node,P=this.prop(l);return w("=",g(i(),P,E),x)},destructureSet(l){const{computed:x}=l.node,E=this.prop(l);return g(i(),E,x)},call(l,x){return(0,C.default)(this.get(l),i(),x,!1)},optionalCall(l,x){return(0,C.default)(this.get(l),i(),x,!0)}});class D{constructor(x){var E;const P=x.methodPath;this.methodPath=P,this.isDerivedConstructor=P.isClassMethod({kind:"constructor"})&&!!x.superRef,this.isStatic=P.isObjectMethod()||P.node.static||(P.isStaticBlock==null?void 0:P.isStaticBlock()),this.isPrivateMethod=P.isPrivate()&&P.isMethod(),this.file=x.file,this.constantSuper=(E=x.constantSuper)!=null?E:x.isLoose,this.opts=x}getObjectRef(){return v(this.opts.objectRef||this.opts.getObjectRef())}getSuperRef(){if(this.opts.superRef)return v(this.opts.superRef);if(this.opts.getSuperRef)return v(this.opts.getSuperRef())}replace(){this.opts.refToPreserve&&this.methodPath.traverse(u,{refName:this.opts.refToPreserve.name});const x=this.constantSuper?h:I;(0,L.default)(this.methodPath,a,Object.assign({file:this.file,scope:this.methodPath.scope,isDerivedConstructor:this.isDerivedConstructor,isStatic:this.isStatic,isPrivateMethod:this.isPrivateMethod,getObjectRef:this.getObjectRef.bind(this),getSuperRef:this.getSuperRef.bind(this),boundGet:x.get},x))}}return fe.default=D,fe}var ye={},st;function Kt(){if(st)return ye;st=1,Object.defineProperty(ye,"__esModule",{value:!0}),ye.isTransparentExprWrapper=v,ye.skipTransparentExprWrapperNodes=g,ye.skipTransparentExprWrappers=d;var e=Ze();const{isParenthesizedExpression:L,isTSAsExpression:C,isTSNonNullExpression:j,isTSSatisfiesExpression:w,isTSTypeAssertion:S,isTypeCastExpression:F}=e;function v(m){return C(m)||w(m)||S(m)||j(m)||F(m)||L(m)}function d(m){for(;v(m.node);)m=m.get("expression");return m}function g(m){for(;v(m);)m=m.expression;return m}return ye}var Oe={},rt;function It(){if(rt)return Oe;rt=1,Object.defineProperty(Oe,"__esModule",{value:!0}),Oe.assertFieldTransformed=e;function e(L){if(L.node.declare)throw L.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`)}return Oe}var nt;function Jt(){if(nt)return le;nt=1,Object.defineProperty(le,"__esModule",{value:!0}),le.buildCheckInRHS=f,le.buildFieldsInitNodes=B,le.buildPrivateNamesMap=d,le.buildPrivateNamesNodes=g,le.transformPrivateNamesUsage=h;var e=oe(),L=jt(),C=Me(),j=St(),w=wt(),S=Et(),F=Kt(),v=It();function d(t){const s=new Map;for(const b of t)if(b.isPrivate()){const{name:c}=b.node.key.id,y=s.has(c)?s.get(c):{id:b.scope.generateUidIdentifier(c),static:b.node.static,method:!b.isProperty()};b.isClassPrivateMethod()&&(b.node.kind==="get"?y.getId=b.scope.generateUidIdentifier(`get_${c}`):b.node.kind==="set"?y.setId=b.scope.generateUidIdentifier(`set_${c}`):b.node.kind==="method"&&(y.methodId=b.scope.generateUidIdentifier(c))),s.set(c,y)}return s}function g(t,s,b,c){const y=[];for(const[_,T]of t){const{static:V,method:U,getId:K,setId:ee}=T,Z=K||ee,te=e.types.cloneNode(T.id);let G;s?G=e.types.callExpression(c.addHelper("classPrivateFieldLooseKey"),[e.types.stringLiteral(_)]):b?G=e.types.callExpression(e.types.identifier("Symbol"),[e.types.stringLiteral(_)]):V||(G=e.types.newExpression(e.types.identifier(!U||Z?"WeakMap":"WeakSet"),[])),G&&((0,S.default)(G),y.push(e.template.statement.ast`var ${te} = ${G}`))}return y}function m(t){const s=e.traverse.visitors.merge([Object.assign({},t),C.default]),b=Object.assign({},t,{Class(c){const{privateNamesMap:y}=this,_=c.get("body.body"),T=new Map(y),V=[];for(const U of _){if(!U.isPrivate())continue;const{name:K}=U.node.key.id;T.delete(K),V.push(K)}V.length&&(c.get("body").traverse(s,Object.assign({},this,{redeclared:V})),c.traverse(b,Object.assign({},this,{privateNamesMap:T})),c.skipKey("body"))}});return b}const R=m({PrivateName(t,{noDocumentAll:s}){const{privateNamesMap:b,redeclared:c}=this,{node:y,parentPath:_}=t;if(!_.isMemberExpression({property:y})&&!_.isOptionalMemberExpression({property:y}))return;const{name:T}=y.id;b.has(T)&&(c&&c.includes(T)||this.handle(_,s))}});function i(t,s,b){for(;(c=s)!=null&&c.hasBinding(t)&&!s.bindingIdentifierEquals(t,b);){var c;s.rename(t),s=s.parent}}function f(t,s,b){return b||!(s.availableHelper!=null&&s.availableHelper("checkInRHS"))?t:e.types.callExpression(s.addHelper("checkInRHS"),[t])}const a=m({BinaryExpression(t,{file:s}){const{operator:b,left:c,right:y}=t.node;if(b!=="in"||!e.types.isPrivateName(c))return;const{privateFieldsAsProperties:_,privateNamesMap:T,redeclared:V}=this,{name:U}=c.id;if(!T.has(U)||V&&V.includes(U))return;if(i(this.classRef.name,t.scope,this.innerBinding),_){const{id:Z}=T.get(U);t.replaceWith(e.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${f(y,s)}, ${e.types.cloneNode(Z)})
      `);return}const{id:K,static:ee}=T.get(U);if(ee){t.replaceWith(e.template.expression.ast`${f(y,s)} === ${e.types.cloneNode(this.classRef)}`);return}t.replaceWith(e.template.expression.ast`${e.types.cloneNode(K)}.has(${f(y,s)})`)}}),u={memoise(t,s){const{scope:b}=t,{object:c}=t.node,y=b.maybeGenerateMemoised(c);y&&this.memoiser.set(c,y,s)},receiver(t){const{object:s}=t.node;return this.memoiser.has(s)?e.types.cloneNode(this.memoiser.get(s)):e.types.cloneNode(s)},get(t){const{classRef:s,privateNamesMap:b,file:c,innerBinding:y}=this,{name:_}=t.node.property.id,{id:T,static:V,method:U,methodId:K,getId:ee,setId:Z}=b.get(_),te=ee||Z;if(V){const G=U&&!te?"classStaticPrivateMethodGet":"classStaticPrivateFieldSpecGet";return i(s.name,t.scope,y),e.types.callExpression(c.addHelper(G),[this.receiver(t),e.types.cloneNode(s),e.types.cloneNode(T)])}if(U){if(te){if(!ee&&Z){if(c.availableHelper("writeOnlyError"))return e.types.sequenceExpression([this.receiver(t),e.types.callExpression(c.addHelper("writeOnlyError"),[e.types.stringLiteral(`#${_}`)])]);console.warn("@babel/helpers is outdated, update it to silence this warning.")}return e.types.callExpression(c.addHelper("classPrivateFieldGet"),[this.receiver(t),e.types.cloneNode(T)])}return e.types.callExpression(c.addHelper("classPrivateMethodGet"),[this.receiver(t),e.types.cloneNode(T),e.types.cloneNode(K)])}return e.types.callExpression(c.addHelper("classPrivateFieldGet"),[this.receiver(t),e.types.cloneNode(T)])},boundGet(t){return this.memoise(t,1),e.types.callExpression(e.types.memberExpression(this.get(t),e.types.identifier("bind")),[this.receiver(t)])},set(t,s){const{classRef:b,privateNamesMap:c,file:y}=this,{name:_}=t.node.property.id,{id:T,static:V,method:U,setId:K,getId:ee}=c.get(_),Z=ee||K;if(V){const te=U&&!Z?"classStaticPrivateMethodSet":"classStaticPrivateFieldSpecSet";return e.types.callExpression(y.addHelper(te),[this.receiver(t),e.types.cloneNode(b),e.types.cloneNode(T),s])}return U?K?e.types.callExpression(y.addHelper("classPrivateFieldSet"),[this.receiver(t),e.types.cloneNode(T),s]):e.types.sequenceExpression([this.receiver(t),s,e.types.callExpression(y.addHelper("readOnlyError"),[e.types.stringLiteral(`#${_}`)])]):e.types.callExpression(y.addHelper("classPrivateFieldSet"),[this.receiver(t),e.types.cloneNode(T),s])},destructureSet(t){const{classRef:s,privateNamesMap:b,file:c}=this,{name:y}=t.node.property.id,{id:_,static:T}=b.get(y);if(T){try{var V=c.addHelper("classStaticPrivateFieldDestructureSet")}catch{throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.")}return e.types.memberExpression(e.types.callExpression(V,[this.receiver(t),e.types.cloneNode(s),e.types.cloneNode(_)]),e.types.identifier("value"))}return e.types.memberExpression(e.types.callExpression(c.addHelper("classPrivateFieldDestructureSet"),[this.receiver(t),e.types.cloneNode(_)]),e.types.identifier("value"))},call(t,s){return this.memoise(t,1),(0,w.default)(this.get(t),this.receiver(t),s,!1)},optionalCall(t,s){return this.memoise(t,1),(0,w.default)(this.get(t),this.receiver(t),s,!0)},delete(){throw new Error("Internal Babel error: deleting private elements is a parsing error.")}},I={get(t){const{privateNamesMap:s,file:b}=this,{object:c}=t.node,{name:y}=t.node.property.id;return e.template.expression`BASE(REF, PROP)[PROP]`({BASE:b.addHelper("classPrivateFieldLooseBase"),REF:e.types.cloneNode(c),PROP:e.types.cloneNode(s.get(y).id)})},set(){throw new Error("private name handler with loose = true don't need set()")},boundGet(t){return e.types.callExpression(e.types.memberExpression(this.get(t),e.types.identifier("bind")),[e.types.cloneNode(t.node.object)])},simpleSet(t){return this.get(t)},destructureSet(t){return this.get(t)},call(t,s){return e.types.callExpression(this.get(t),s)},optionalCall(t,s){return e.types.optionalCallExpression(this.get(t),s,!0)},delete(){throw new Error("Internal Babel error: deleting private elements is a parsing error.")}};function h(t,s,b,{privateFieldsAsProperties:c,noDocumentAll:y,innerBinding:_},T){if(!b.size)return;const V=s.get("body"),U=c?I:u;(0,j.default)(V,R,Object.assign({privateNamesMap:b,classRef:t,file:T},U,{noDocumentAll:y,innerBinding:_})),V.traverse(a,{privateNamesMap:b,classRef:t,file:T,privateFieldsAsProperties:c,innerBinding:_})}function D(t,s,b){const{id:c}=b.get(s.node.key.id.name),y=s.node.value||s.scope.buildUndefinedNode();return k(e.template.statement.ast`
      Object.defineProperty(${t}, ${e.types.cloneNode(c)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${y}
      });
    `,s)}function l(t,s,b,c){const{id:y}=b.get(s.node.key.id.name),_=s.node.value||s.scope.buildUndefinedNode();if(!c.availableHelper("classPrivateFieldInitSpec"))return k(e.template.statement.ast`${e.types.cloneNode(y)}.set(${t}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${_},
        })`,s);const T=c.addHelper("classPrivateFieldInitSpec");return k(e.template.statement.ast`${T}(
      ${e.types.thisExpression()},
      ${e.types.cloneNode(y)},
      {
        writable: true,
        value: ${_}
      },
    )`,s)}function x(t,s){const b=s.get(t.node.key.id.name),{id:c,getId:y,setId:_,initAdded:T}=b,V=y||_;if(!t.isProperty()&&(T||!V))return;if(V)return s.set(t.node.key.id.name,Object.assign({},b,{initAdded:!0})),k(e.template.statement.ast`
        var ${e.types.cloneNode(c)} = {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${y?y.name:t.scope.buildUndefinedNode()},
          set: ${_?_.name:t.scope.buildUndefinedNode()}
        }
      `,t);const U=t.node.value||t.scope.buildUndefinedNode();return k(e.template.statement.ast`
      var ${e.types.cloneNode(c)} = {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${U}
      };
    `,t)}function E(t,s,b){const c=b.get(s.node.key.id.name),{methodId:y,id:_,getId:T,setId:V,initAdded:U}=c;if(U)return;if(y)return k(e.template.statement.ast`
        Object.defineProperty(${t}, ${_}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${y.name}
        });
      `,s);if(T||V)return b.set(s.node.key.id.name,Object.assign({},c,{initAdded:!0})),k(e.template.statement.ast`
        Object.defineProperty(${t}, ${_}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${T?T.name:s.scope.buildUndefinedNode()},
          set: ${V?V.name:s.scope.buildUndefinedNode()}
        });
      `,s)}function P(t,s,b,c){const y=b.get(s.node.key.id.name),{getId:_,setId:T,initAdded:V}=y;return V?void 0:_||T?M(t,s,b,c):H(t,s,b,c)}function M(t,s,b,c){const y=b.get(s.node.key.id.name),{id:_,getId:T,setId:V}=y;if(b.set(s.node.key.id.name,Object.assign({},y,{initAdded:!0})),!c.availableHelper("classPrivateFieldInitSpec"))return k(e.template.statement.ast`
          ${_}.set(${t}, {
            get: ${T?T.name:s.scope.buildUndefinedNode()},
            set: ${V?V.name:s.scope.buildUndefinedNode()}
          });
        `,s);const U=c.addHelper("classPrivateFieldInitSpec");return k(e.template.statement.ast`${U}(
      ${e.types.thisExpression()},
      ${e.types.cloneNode(_)},
      {
        get: ${T?T.name:s.scope.buildUndefinedNode()},
        set: ${V?V.name:s.scope.buildUndefinedNode()}
      },
    )`,s)}function H(t,s,b,c){const y=b.get(s.node.key.id.name),{id:_}=y;if(!c.availableHelper("classPrivateMethodInitSpec"))return k(e.template.statement.ast`${_}.add(${t})`,s);const T=c.addHelper("classPrivateMethodInitSpec");return k(e.template.statement.ast`${T}(
      ${e.types.thisExpression()},
      ${e.types.cloneNode(_)}
    )`,s)}function $(t,s){const{key:b,computed:c}=s.node,y=s.node.value||s.scope.buildUndefinedNode();return k(e.types.expressionStatement(e.types.assignmentExpression("=",e.types.memberExpression(t,b,c||e.types.isLiteral(b)),y)),s)}function q(t,s,b){const{key:c,computed:y}=s.node,_=s.node.value||s.scope.buildUndefinedNode();return k(e.types.expressionStatement(e.types.callExpression(b.addHelper("defineProperty"),[t,y||e.types.isLiteral(c)?c:e.types.stringLiteral(c.name),_])),s)}function r(t,s,b,c){const y=c.get(s.node.key.id.name),{id:_,methodId:T,getId:V,setId:U,initAdded:K}=y;return K?void 0:V||U?(c.set(s.node.key.id.name,Object.assign({},y,{initAdded:!0})),k(e.template.statement.ast`
        Object.defineProperty(${t}, ${_}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${V?V.name:s.scope.buildUndefinedNode()},
          set: ${U?U.name:s.scope.buildUndefinedNode()}
        })
      `,s)):k(e.template.statement.ast`
      Object.defineProperty(${t}, ${_}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${T.name}
      });
    `,s)}function n(t,s,b=!1){const c=s.get(t.node.key.id.name),{id:y,methodId:_,getId:T,setId:V,getterDeclared:U,setterDeclared:K,static:ee}=c,{params:Z,body:te,generator:G,async:z}=t.node,X=T&&!U&&Z.length===0,se=V&&!K&&Z.length>0;let re=_;return X?(s.set(t.node.key.id.name,Object.assign({},c,{getterDeclared:!0})),re=T):se?(s.set(t.node.key.id.name,Object.assign({},c,{setterDeclared:!0})),re=V):ee&&!b&&(re=y),k(e.types.functionDeclaration(e.types.cloneNode(re),Z,te,G,z),t)}const A=e.traverse.visitors.merge([{UnaryExpression(t){const{node:s}=t;if(s.operator==="delete"){const b=(0,F.skipTransparentExprWrapperNodes)(s.argument);e.types.isThisExpression(b)&&t.replaceWith(e.types.booleanLiteral(!0))}},ThisExpression(t,s){s.needsClassRef=!0,t.replaceWith(e.types.cloneNode(s.classRef))},MetaProperty(t){const{node:s,scope:b}=t;s.meta.name==="new"&&s.property.name==="target"&&t.replaceWith(b.buildUndefinedNode())}},C.default]),p={ReferencedIdentifier(t,s){t.scope.bindingIdentifierEquals(t.node.name,s.innerBinding)&&(s.needsClassRef=!0,t.node.name=s.classRef.name)}};function O(t,s,b){var c;const y={classRef:s,needsClassRef:!1,innerBinding:b};return t.isMethod()||t.traverse(A,y),b!=null&&(c=y.classRef)!=null&&c.name&&y.classRef.name!==b.name&&t.traverse(p,y),y.needsClassRef}function N({key:t,computed:s}){return t.type==="Identifier"?!s&&(t.name==="name"||t.name==="length"):t.type==="StringLiteral"?t.value==="name"||t.value==="length":!1}function k(t,s){return e.types.inheritLeadingComments(t,s.node),e.types.inheritInnerComments(t,s.node),t}function B(t,s,b,c,y,_,T,V,U){var K,ee;let Z=0,te;const G=[],z=[],X=[];let se=null;const re=e.types.isIdentifier(s)?()=>s:()=>{var W;return(W=te)!=null||(te=b[0].scope.generateUidIdentifierBasedOnNode(s)),te},J=(K=t)!=null?K:b[0].scope.generateUidIdentifier("class");(ee=t)!=null||(t=e.types.cloneNode(U));for(const W of b){W.isClassProperty()&&v.assertFieldTransformed(W);const ne=!(e.types.isStaticBlock!=null&&e.types.isStaticBlock(W.node))&&W.node.static,he=!ne,ie=W.isPrivate(),ke=!ie,ae=W.isProperty(),Pe=!ae,Ue=W.isStaticBlock==null?void 0:W.isStaticBlock();switch(ne&&(Z|=1),(ne||Pe&&ie||Ue)&&(new L.default({methodPath:W,constantSuper:V,file:y,refToPreserve:U,getSuperRef:re,getObjectRef(){return Z|=2,ne||Ue?J:e.types.memberExpression(J,e.types.identifier("prototype"))}}).replace(),O(W,J,U)&&(Z|=2)),!0){case Ue:{const Se=W.node.body;Se.length===1&&e.types.isExpressionStatement(Se[0])?G.push(k(Se[0],W)):G.push(e.types.inheritsComments(e.template.statement.ast`(() => { ${Se} })()`,W.node));break}case(ne&&ie&&ae&&T):G.push(D(e.types.cloneNode(t),W,c));break;case(ne&&ie&&ae&&!T):G.push(x(W,c));break;case(ne&&ke&&ae&&_):if(!N(W.node)){G.push($(e.types.cloneNode(t),W));break}case(ne&&ke&&ae&&!_):G.push(q(e.types.cloneNode(t),W,y));break;case(he&&ie&&ae&&T):z.push(D(e.types.thisExpression(),W,c));break;case(he&&ie&&ae&&!T):z.push(l(e.types.thisExpression(),W,c,y));break;case(he&&ie&&Pe&&T):z.unshift(E(e.types.thisExpression(),W,c)),X.push(n(W,c,T));break;case(he&&ie&&Pe&&!T):z.unshift(P(e.types.thisExpression(),W,c,y)),X.push(n(W,c,T));break;case(ne&&ie&&Pe&&!T):G.unshift(x(W,c)),X.push(n(W,c,T));break;case(ne&&ie&&Pe&&T):G.unshift(r(e.types.cloneNode(t),W,y,c)),X.push(n(W,c,T));break;case(he&&ke&&ae&&_):z.push($(e.types.thisExpression(),W));break;case(he&&ke&&ae&&!_):z.push(q(e.types.thisExpression(),W,y));break;default:throw new Error("Unreachable.")}}return Z&2&&U!=null&&(se=e.types.expressionStatement(e.types.assignmentExpression("=",e.types.cloneNode(J),e.types.cloneNode(U)))),{staticNodes:G.filter(Boolean),instanceNodes:z.filter(Boolean),pureStaticNodes:X.filter(Boolean),classBindingNode:se,wrapClass(W){for(const ne of b)ne.node.leadingComments=null,ne.remove();return te&&(W.scope.push({id:e.types.cloneNode(te)}),W.set("superClass",e.types.assignmentExpression("=",te,W.node.superClass))),Z!==0&&(W.isClassExpression()?(W.scope.push({id:t}),W.replaceWith(e.types.assignmentExpression("=",e.types.cloneNode(t),W.node))):(U==null&&(W.node.id=t),se!=null&&W.scope.push({id:J}))),W}}}return le}var be={},it;function Nt(){if(it)return be;it=1,Object.defineProperty(be,"__esModule",{value:!0}),be.buildDecoratedClass=R,be.hasDecorators=w,be.hasOwnDecorators=j;var e=oe(),L=jt(),C=Pt();function j(i){var f;return!!((f=i.decorators)!=null&&f.length)}function w(i){return j(i)||i.body.body.some(j)}function S(i,f){return f?e.types.objectProperty(e.types.identifier(i),f):null}function F(i,f){return e.types.objectMethod("method",e.types.identifier(i),[],e.types.blockStatement(f))}function v(i){let f;return i.decorators&&i.decorators.length>0&&(f=e.types.arrayExpression(i.decorators.map(a=>a.expression))),i.decorators=void 0,f}function d(i){return i.computed?i.key:e.types.isIdentifier(i.key)?e.types.stringLiteral(i.key.name):e.types.stringLiteral(String(i.key.value))}function g(i,f,a,u){const I=u.isClassMethod();if(u.isPrivate())throw u.buildCodeFrameError(`Private ${I?"methods":"fields"} in decorated classes are not supported yet.`);if(u.node.type==="ClassAccessorProperty")throw u.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');if(u.node.type==="StaticBlock")throw u.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');const{node:h,scope:D}=u;u.isTSDeclareMethod()||new L.default({methodPath:u,objectRef:f,superRef:a,file:i,refToPreserve:f}).replace();const l=[S("kind",e.types.stringLiteral(e.types.isClassMethod(h)?h.kind:"field")),S("decorators",v(h)),S("static",h.static&&e.types.booleanLiteral(!0)),S("key",d(h))].filter(Boolean);if(e.types.isClassMethod(h)){const x=h.computed?null:h.key,E=e.types.toExpression(h);l.push(S("value",(0,C.default)({node:E,id:x,scope:D})||E))}else e.types.isClassProperty(h)&&h.value?l.push(F("value",e.template.statements.ast`return ${h.value}`)):l.push(S("value",D.buildUndefinedNode()));return u.remove(),e.types.objectExpression(l)}function m(i){return i.addHelper("decorate")}function R(i,f,a,u){const{node:I,scope:h}=f,D=h.generateUidIdentifier("initialize"),l=I.id&&f.isDeclaration(),x=f.isInStrictMode(),{superClass:E}=I;I.type="ClassDeclaration",I.id||(I.id=e.types.cloneNode(i));let P;E&&(P=h.generateUidIdentifierBasedOnNode(I.superClass,"super"),I.superClass=P);const M=v(I),H=e.types.arrayExpression(a.filter(n=>!n.node.abstract&&n.node.type!=="TSIndexSignature").map(n=>g(u,I.id,P,n))),$=e.template.expression.ast`
    ${m(u)}(
      ${M||e.types.nullLiteral()},
      function (${D}, ${E?e.types.cloneNode(P):null}) {
        ${I}
        return { F: ${e.types.cloneNode(I.id)}, d: ${H} };
      },
      ${E}
    )
  `;x||$.arguments[1].body.directives.push(e.types.directive(e.types.directiveLiteral("use strict")));let q=$,r="arguments.1.body.body.0";return l&&(q=e.template.statement.ast`let ${i} = ${$}`,r="declarations.0.init."+r),{instanceNodes:[e.template.statement.ast`${e.types.cloneNode(D)}(this)`],wrapClass(n){return n.replaceWith(q),n.get(r)}}}return be}var Ie={},ot;function Zt(){if(ot)return Ie;ot=1,Object.defineProperty(Ie,"__esModule",{value:!0}),Ie.extractComputedKeys=v,Ie.injectInitialization=F;var e=oe(),L=Me();const C=e.traverse.visitors.merge([{Super(d){const{node:g,parentPath:m}=d;m.isCallExpression({callee:g})&&this.push(m)}},L.default]),j={"TSTypeAnnotation|TypeAnnotation"(d){d.skip()},ReferencedIdentifier(d,{scope:g}){g.hasOwnBinding(d.node.name)&&(g.rename(d.node.name),d.skip())}};function w(d,g){if(g.classBinding&&g.classBinding===d.scope.getBinding(d.node.name)){const m=g.file.addHelper("classNameTDZError"),R=e.types.callExpression(m,[e.types.stringLiteral(d.node.name)]);d.replaceWith(e.types.sequenceExpression([R,d.node])),d.skip()}}const S={ReferencedIdentifier:w};function F(d,g,m,R){if(!m.length)return;const i=!!d.node.superClass;if(!g){const f=e.types.classMethod("constructor",e.types.identifier("constructor"),[],e.types.blockStatement([]));i&&(f.params=[e.types.restElement(e.types.identifier("args"))],f.body.body.push(e.template.statement.ast`super(...args)`)),[g]=d.get("body").unshiftContainer("body",f)}if(R&&R(j,{scope:g.scope}),i){const f=[];g.traverse(C,f);let a=!0;for(const u of f)a?(u.insertAfter(m),a=!1):u.insertAfter(m.map(I=>e.types.cloneNode(I)))}else g.get("body").unshiftContainer("body",m)}function v(d,g,m){const R=[],i={classBinding:d.node.id&&d.scope.getBinding(d.node.id.name),file:m};for(const f of g){const a=f.get("key");a.isReferencedIdentifier()?w(a,i):a.traverse(S,i);const u=f.node;if(!a.isConstantExpression()){const I=d.scope.generateUidIdentifierBasedOnNode(u.key);d.scope.push({id:I,kind:"let"}),R.push(e.types.expressionStatement(e.types.assignmentExpression("=",e.types.cloneNode(I),u.key))),u.key=e.types.cloneNode(I)}}return R}return Ie}var ce={},at;function Xt(){if(at)return ce;at=1,Object.defineProperty(ce,"__esModule",{value:!0}),ce.FEATURES=void 0,ce.enableFeature=F,ce.isLoose=d,ce.shouldTransform=R;var e=Nt();const L=Object.freeze({fields:2,privateMethods:4,decorators:8,privateIn:16,staticBlocks:32});ce.FEATURES=L;const C=new Map([[L.fields,"@babel/plugin-transform-class-properties"],[L.privateMethods,"@babel/plugin-transform-private-methods"],[L.privateIn,"@babel/plugin-transform-private-property-in-object"]]),j="@babel/plugin-class-features/featuresKey",w="@babel/plugin-class-features/looseKey",S="@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";function F(i,f,a){(!v(i,f)||m(i,f))&&(i.set(j,i.get(j)|f),a==="#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error"?(g(i,f,!0),i.set(S,i.get(S)|f)):a==="#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"?(g(i,f,!1),i.set(S,i.get(S)|f)):g(i,f,a));let u,I;for(const[h,D]of C){if(!v(i,h))continue;const l=d(i,h);if(!m(i,h)){if(u===!l)throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).");u=l,I=D}}if(u!==void 0)for(const[h,D]of C)v(i,h)&&d(i,h)!==u&&(g(i,h,u),console.warn(`Though the "loose" option was set to "${!u}" in your @babel/preset-env config, it will not be used for ${D} since the "loose" mode option was set to "${u}" for ${I}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${D}", { "loose": ${u} }]
to the "plugins" section of your Babel config.`))}function v(i,f){return!!(i.get(j)&f)}function d(i,f){return!!(i.get(w)&f)}function g(i,f,a){a?i.set(w,i.get(w)|f):i.set(w,i.get(w)&~f),i.set(S,i.get(S)&~f)}function m(i,f){return!!(i.get(S)&f)}function R(i,f){let a=null,u=null,I=null,h=null,D=null;(0,e.hasOwnDecorators)(i.node)&&(a=i.get("decorators.0"));for(const l of i.get("body.body"))!a&&(0,e.hasOwnDecorators)(l.node)&&(a=l.get("decorators.0")),!u&&l.isClassProperty()&&(u=l),!I&&l.isClassPrivateProperty()&&(I=l),!h&&l.isClassPrivateMethod!=null&&l.isClassPrivateMethod()&&(h=l),!D&&l.isStaticBlock!=null&&l.isStaticBlock()&&(D=l);if(a&&I)throw I.buildCodeFrameError("Private fields in decorated classes are not supported yet.");if(a&&h)throw h.buildCodeFrameError("Private methods in decorated classes are not supported yet.");if(a&&!v(f,L.decorators))throw i.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);if(h&&!v(f,L.privateMethods))throw h.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");if((u||I)&&!v(f,L.fields)&&!v(f,L.privateMethods))throw i.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");if(D&&!v(f,L.staticBlocks))throw i.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");return!!(a||h||D||(u||I)&&v(f,L.fields))}return ce}var lt;function Yt(){return lt||(lt=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"FEATURES",{enumerable:!0,get:function(){return d.FEATURES}}),Object.defineProperty(e,"buildCheckInRHS",{enumerable:!0,get:function(){return S.buildCheckInRHS}}),e.createClassFeaturePlugin=R,Object.defineProperty(e,"enableFeature",{enumerable:!0,get:function(){return d.enableFeature}}),Object.defineProperty(e,"injectInitialization",{enumerable:!0,get:function(){return v.injectInitialization}});var L=oe(),C=Pt(),j=_t(),w=$t(),S=Jt(),F=Nt(),v=Zt(),d=Xt(),g=It();const m="@babel/plugin-class-features/version";function R({name:i,feature:f,loose:a,manipulateOptions:u,api:I,inherits:h}){{var D;(D=I)!=null||(I={assumption:()=>{}})}const l=I.assumption("setPublicClassFields"),x=I.assumption("privateFieldsAsSymbols"),E=I.assumption("privateFieldsAsProperties"),P=I.assumption("constantSuper"),M=I.assumption("noDocumentAll");if(E&&x)throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');const H=E||x;if(a===!0){const $=[];l!==void 0&&$.push('"setPublicClassFields"'),E!==void 0&&$.push('"privateFieldsAsProperties"'),x!==void 0&&$.push('"privateFieldsAsSymbols"'),$.length!==0&&console.warn(`[${i}]: You are using the "loose: true" option and you are explicitly setting a value for the ${$.join(" and ")} assumption${$.length>1?"s":""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`)}return{name:i,manipulateOptions:u,inherits:h,pre($){if((0,d.enableFeature)($,f,a),typeof $.get(m)=="number"){$.set(m,"7.22.15");return}(!$.get(m)||w.lt($.get(m),"7.22.15"))&&$.set(m,"7.22.15")},visitor:{Class($,{file:q}){var r;if(q.get(m)!=="7.22.15"||!(0,d.shouldTransform)($,q))return;const n=$.isClassDeclaration();n&&(0,g.assertFieldTransformed)($);const A=(0,d.isLoose)(q,f);let p;const O=(0,F.hasDecorators)($.node),N=[],k=[],B=[],t=new Set,s=$.get("body");for(const z of s.get("body")){if((z.isClassProperty()||z.isClassMethod())&&z.node.computed&&B.push(z),z.isPrivate()){const{name:X}=z.node.key.id,se=`get ${X}`,re=`set ${X}`;if(z.isClassPrivateMethod()){if(z.node.kind==="get"){if(t.has(se)||t.has(X)&&!t.has(re))throw z.buildCodeFrameError("Duplicate private field");t.add(se).add(X)}else if(z.node.kind==="set"){if(t.has(re)||t.has(X)&&!t.has(se))throw z.buildCodeFrameError("Duplicate private field");t.add(re).add(X)}}else{if(t.has(X)&&!t.has(se)&&!t.has(re)||t.has(X)&&(t.has(se)||t.has(re)))throw z.buildCodeFrameError("Duplicate private field");t.add(X)}}z.isClassMethod({kind:"constructor"})?p=z:(k.push(z),(z.isProperty()||z.isPrivate()||z.isStaticBlock!=null&&z.isStaticBlock())&&N.push(z))}if(!N.length&&!O)return;const b=$.node.id;let c;(!b||!n)&&((0,C.default)($),c=$.scope.generateUidIdentifier("class"));const y=(r=c)!=null?r:L.types.cloneNode(b),_=(0,S.buildPrivateNamesMap)(N),T=(0,S.buildPrivateNamesNodes)(_,E??A,x??!1,q);(0,S.transformPrivateNamesUsage)(y,$,_,{privateFieldsAsProperties:H??A,noDocumentAll:M,innerBinding:b},q);let V,U,K,ee,Z,te;O?(U=ee=V=[],{instanceNodes:K,wrapClass:te}=(0,F.buildDecoratedClass)(y,$,k,q)):(V=(0,v.extractComputedKeys)($,B,q),{staticNodes:U,pureStaticNodes:ee,instanceNodes:K,classBindingNode:Z,wrapClass:te}=(0,S.buildFieldsInitNodes)(c,$.node.superClass,N,_,q,l??A,H??A,P??A,b)),K.length>0&&(0,v.injectInitialization)($,p,K,(z,X)=>{if(!O)for(const se of N)L.types.isStaticBlock!=null&&L.types.isStaticBlock(se.node)||se.node.static||se.traverse(z,X)});const G=te($);G.insertBefore([...T,...V]),U.length>0&&G.insertAfter(U),ee.length>0&&G.find(z=>z.isStatement()||z.isDeclaration()).insertAfter(ee),Z!=null&&n&&G.insertAfter(Z)},ExportDefaultDeclaration($,{file:q}){{if(q.get(m)!=="7.22.15")return;const r=$.get("declaration");r.isClassDeclaration()&&(0,F.hasDecorators)(r.node)&&(r.node.id?(0,j.default)($):r.node.type="ClassExpression")}}}}}}(ze)),ze}var Re={},Ne={},ct;function Tt(){if(ct)return Ne;ct=1,Object.defineProperty(Ne,"__esModule",{value:!0}),Ne.default=S,Ne.translateEnumValues=i;var e=oe(),L=Dt(),C=Et();const j=new WeakMap,w=e.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);function S(a,u){const{node:I,parentPath:h}=a;if(I.declare){a.remove();return}const D=I.id.name,{fill:l,data:x,isPure:E}=g(a,u,I.id);switch(h.type){case"BlockStatement":case"ExportNamedDeclaration":case"Program":{const M=u.isProgram(a.parent),H=P(h);let $=u.objectExpression([]);(H||M)&&($=u.logicalExpression("||",u.cloneNode(l.ID),$));const q=w(Object.assign({},l,{INIT:$}));E&&(0,C.default)(q),H?(h.isExportDeclaration()?h:a).replaceWith(u.expressionStatement(u.assignmentExpression("=",u.cloneNode(I.id),q))):a.scope.registerDeclaration(a.replaceWith(u.variableDeclaration(M?"var":"let",[u.variableDeclarator(I.id,q)]))[0]),j.set(a.scope.getBindingIdentifier(D),x);break}default:throw new Error(`Unexpected enum parent '${a.parent.type}`)}function P(M){return M.isExportDeclaration()?P(M.parentPath):M.getData(D)?!0:(M.setData(D,!0),!1)}}const F=(0,e.template)(`
  ENUM["NAME"] = VALUE;
`),v=(0,e.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`),d=(a,u)=>(a?F:v)(u);function g(a,u,I){const{enumValues:h,data:D,isPure:l}=i(a,u),x=h.map(([E,P])=>d(u.isStringLiteral(P),{ENUM:u.cloneNode(I),NAME:E,VALUE:P}));return{fill:{ID:u.cloneNode(I),ASSIGNMENTS:x},data:D,isPure:l}}function m(a,u){const{seen:I,path:h,t:D}=u,l=a.node.name;I.has(l)&&!a.scope.hasOwnBinding(l)&&(a.replaceWith(D.memberExpression(D.cloneNode(h.node.id),D.cloneNode(a.node))),a.skip())}const R={ReferencedIdentifier:m};function i(a,u){const I=new Map;let h=-1,D,l=!0;const x=a.get("members").map(E=>{const P=E.node,M=u.isIdentifier(P.id)?P.id.name:P.id.value,H=E.get("initializer"),$=P.initializer;let q;if($)h=f(H,I),h!==void 0?(I.set(M,h),L(typeof h=="number"||typeof h=="string"),h===1/0||Number.isNaN(h)?q=u.identifier(String(h)):h===-1/0?q=u.unaryExpression("-",u.identifier("Infinity")):q=u.valueToNode(h)):(l&&(l=H.isPure()),H.isReferencedIdentifier()?m(H,{t:u,seen:I,path:a}):H.traverse(R,{t:u,seen:I,path:a}),q=H.node,I.set(M,void 0));else if(typeof h=="number")h+=1,q=u.numericLiteral(h),I.set(M,h);else{if(typeof h=="string")throw a.buildCodeFrameError("Enum member must have initializer.");{const r=u.memberExpression(u.cloneNode(a.node.id),u.stringLiteral(D),!0);q=u.binaryExpression("+",u.numericLiteral(1),r),I.set(M,void 0)}}return D=M,[M,q]});return{isPure:l,data:I,enumValues:x}}function f(a,u,I=new Set){return h(a);function h(E){const P=E.node;switch(P.type){case"MemberExpression":return D(E,u,I);case"StringLiteral":return P.value;case"UnaryExpression":return l(E);case"BinaryExpression":return x(E);case"NumericLiteral":return P.value;case"ParenthesizedExpression":return h(E.get("expression"));case"Identifier":return D(E,u,I);case"TemplateLiteral":{if(P.quasis.length===1)return P.quasis[0].value.cooked;const M=E.get("expressions"),H=P.quasis;let $="";for(let q=0;q<H.length;q++)if($+=H[q].value.cooked,q+1<H.length){const r=D(M[q],u,I);if(r===void 0)return;$+=r}return $}default:return}}function D(E,P,M){if(E.isMemberExpression()){const H=E.node,$=H.object,q=H.property;if(!e.types.isIdentifier($)||(H.computed?!e.types.isStringLiteral(q):!e.types.isIdentifier(q)))return;const r=E.scope.getBindingIdentifier($.name),n=j.get(r);return n?n.get(q.computed?q.value:q.name):void 0}else if(E.isIdentifier()){const H=E.node.name;if(["Infinity","NaN"].includes(H))return Number(H);let $=P==null?void 0:P.get(H);if($!==void 0)return $;if(M.has(E.node))return;const q=E.resolve();if(q)return M.add(E.node),$=f(q,void 0,M),P==null||P.set(H,$),$}}function l(E){const P=h(E.get("argument"));if(P!==void 0)switch(E.node.operator){case"+":return P;case"-":return-P;case"~":return~P;default:return}}function x(E){const P=h(E.get("left"));if(P===void 0)return;const M=h(E.get("right"));if(M!==void 0)switch(E.node.operator){case"|":return P|M;case"&":return P&M;case">>":return P>>M;case">>>":return P>>>M;case"<<":return P<<M;case"^":return P^M;case"*":return P*M;case"/":return P/M;case"+":return P+M;case"-":return P-M;case"%":return P%M;case"**":return Math.pow(P,M);default:return}}}return Ne}var dt;function Qt(){if(dt)return Re;dt=1,Object.defineProperty(Re,"__esModule",{value:!0}),Re.default=L;var e=Tt();function L(C,j){const{name:w}=C.node.id,S=C.parentPath.isExportNamedDeclaration();let F=S;!F&&j.isProgram(C.parent)&&(F=C.parent.body.some(g=>j.isExportNamedDeclaration(g)&&g.exportKind!=="type"&&!g.source&&g.specifiers.some(m=>j.isExportSpecifier(m)&&m.exportKind!=="type"&&m.local.name===w)));const{enumValues:v}=(0,e.translateEnumValues)(C,j);if(F){const g=j.objectExpression(v.map(([m,R])=>j.objectProperty(j.isValidIdentifier(m)?j.identifier(m):j.stringLiteral(m),R)));C.scope.hasOwnBinding(w)?(S?C.parentPath:C).replaceWith(j.expressionStatement(j.callExpression(j.memberExpression(j.identifier("Object"),j.identifier("assign")),[C.node.id,g]))):(C.replaceWith(j.variableDeclaration("var",[j.variableDeclarator(C.node.id,g)])),C.scope.registerDeclaration(C));return}const d=new Map(v);C.scope.path.traverse({Scope(g){g.scope.hasOwnBinding(w)&&g.skip()},MemberExpression(g){if(!j.isIdentifier(g.node.object,{name:w}))return;let m;if(g.node.computed)if(j.isStringLiteral(g.node.property))m=g.node.property.value;else return;else if(j.isIdentifier(g.node.property))m=g.node.property.name;else return;d.has(m)&&g.replaceWith(j.cloneNode(d.get(m)))}}),C.remove()}return Re}var me={},ut;function Ct(){if(ut)return me;ut=1,Object.defineProperty(me,"__esModule",{value:!0}),me.GLOBAL_TYPES=void 0,me.isGlobalType=L,me.registerGlobalType=C;const e=me.GLOBAL_TYPES=new WeakMap;function L({scope:j},w){return j.hasBinding(w)?!1:e.get(j).has(w)?!0:(console.warn(`The exported identifier "${w}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${w}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`),!1)}function C(j,w){e.get(j).add(w)}return me}var Be={},pt;function es(){if(pt)return Be;pt=1,Object.defineProperty(Be,"__esModule",{value:!0}),Be.default=C;var e=oe(),L=Ct();function C(d,g){if(d.node.declare||d.node.id.type==="StringLiteral"){d.remove();return}if(!g)throw d.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const m=d.node.id.name,R=v(d,e.types.cloneNode(d.node,!0));if(R===null){const i=d.findParent(f=>f.isProgram());(0,L.registerGlobalType)(i.scope,m),d.remove()}else d.scope.hasOwnBinding(m)?d.replaceWith(R):d.scope.registerDeclaration(d.replaceWithMultiple([j(m),R])[0])}function j(d){return e.types.variableDeclaration("let",[e.types.variableDeclarator(e.types.identifier(d))])}function w(d,g){return e.types.memberExpression(e.types.identifier(d),e.types.identifier(g))}function S(d,g,m){if(d.kind!=="const")throw m.file.buildCodeFrameError(d,"Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const{declarations:R}=d;if(R.every(a=>e.types.isIdentifier(a.id))){for(const a of R)a.init=e.types.assignmentExpression("=",w(g,a.id.name),a.init);return[d]}const i=e.types.getBindingIdentifiers(d),f=[];for(const a in i)f.push(e.types.assignmentExpression("=",w(g,a),e.types.cloneNode(i[a])));return[d,e.types.expressionStatement(e.types.sequenceExpression(f))]}function F(d,g){return d.hub.buildError(g,"Ambient modules cannot be nested in other modules or namespaces.",Error)}function v(d,g,m){const R=new Set,i=g.id;e.types.assertIdentifier(i);const f=d.scope.generateUid(i.name),a=e.types.isTSModuleBlock(g.body)?g.body.body:[e.types.exportNamedDeclaration(g.body)];let u=!0;for(let h=0;h<a.length;h++){const D=a[h];switch(D.type){case"TSModuleDeclaration":{if(!e.types.isIdentifier(D.id))throw F(d,D);const l=v(d,D);if(l!==null){u=!1;const x=D.id.name;R.has(x)?a[h]=l:(R.add(x),a.splice(h++,1,j(x),l))}continue}case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":u=!1,R.add(D.id.name);continue;case"VariableDeclaration":{u=!1;for(const l in e.types.getBindingIdentifiers(D))R.add(l);continue}default:u&&(u=e.types.isTypeScript(D));continue;case"ExportNamedDeclaration":}if(!("declare"in D.declaration&&D.declaration.declare))switch(D.declaration.type){case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":{u=!1;const l=D.declaration.id.name;R.add(l),a.splice(h++,1,D.declaration,e.types.expressionStatement(e.types.assignmentExpression("=",w(f,l),e.types.identifier(l))));break}case"VariableDeclaration":{u=!1;const l=S(D.declaration,f,d.hub);a.splice(h,l.length,...l),h+=l.length-1;break}case"TSModuleDeclaration":{if(!e.types.isIdentifier(D.declaration.id))throw F(d,D.declaration);const l=v(d,D.declaration,e.types.identifier(f));if(l!==null){u=!1;const x=D.declaration.id.name;R.has(x)?a[h]=l:(R.add(x),a.splice(h++,1,j(x),l))}else a.splice(h,1),h--}}}if(u)return null;let I=e.types.objectExpression([]);if(m){const h=e.types.memberExpression(m,i);I=e.template.expression.ast`
      ${e.types.cloneNode(h)} ||
        (${e.types.cloneNode(h)} = ${I})
    `}return e.template.statement.ast`
    (function (${e.types.identifier(f)}) {
      ${a}
    })(${i} || (${e.types.cloneNode(i)} = ${I}));
  `}return Be}var ft;function ts(){if(ft)return we;ft=1,Object.defineProperty(we,"__esModule",{value:!0}),we.default=void 0;var e=Ve(),L=Gt(),C=Yt(),j=Qt(),w=Tt(),S=Ct(),F=es();function v(i){switch(i.parent.type){case"TSTypeReference":case"TSExpressionWithTypeArguments":case"TSTypeQuery":return!0;case"TSQualifiedName":return i.parentPath.findParent(f=>f.type!=="TSQualifiedName").type!=="TSImportEqualsDeclaration";case"ExportSpecifier":return i.parent.exportKind==="type"||i.parentPath.parent.exportKind==="type";default:return!1}}const d=new WeakMap,g=new WeakSet;function m(i){const f=i.getBindingIdentifiers();for(const a of Object.keys(f)){const u=i.scope.getBinding(a);u&&u.identifier===f[a]&&u.scope.removeBinding(a)}i.opts.noScope=!0,i.remove(),i.opts.noScope=!1}function R(i,f,a,u,I=""){if(f.file.get("@babel/plugin-transform-modules-*")!=="commonjs")throw i.buildCodeFrameError(`\`${a}\` is only supported when compiling modules to CommonJS.
Please consider using \`${u}\`${I}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`)}return we.default=(0,e.declare)((i,f)=>{const{types:a,template:u}=i;i.assertVersion(7);const I=/\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/,{allowNamespaces:h=!0,jsxPragma:D="React.createElement",jsxPragmaFrag:l="React.Fragment",onlyRemoveTypeImports:x=!1,optimizeConstEnums:E=!1}=f;var{allowDeclareFields:P=!1}=f;const M={field(r){const{node:n}=r;if(!P&&n.declare)throw r.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");if(n.declare){if(n.value)throw r.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");n.decorators||r.remove()}else if(n.definite){if(n.value)throw r.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");!P&&!n.decorators&&!a.isClassPrivateProperty(n)&&r.remove()}else(n.abstract||!P&&!n.value&&!n.decorators&&!a.isClassPrivateProperty(n))&&r.remove();n.accessibility&&(n.accessibility=null),n.abstract&&(n.abstract=null),n.readonly&&(n.readonly=null),n.optional&&(n.optional=null),n.typeAnnotation&&(n.typeAnnotation=null),n.definite&&(n.definite=null),n.declare&&(n.declare=null),n.override&&(n.override=null)},method({node:r}){r.accessibility&&(r.accessibility=null),r.abstract&&(r.abstract=null),r.optional&&(r.optional=null),r.override&&(r.override=null)},constructor(r,n){r.node.accessibility&&(r.node.accessibility=null);const A=[],{scope:p}=r;for(const O of r.get("params")){const N=O.node;if(N.type==="TSParameterProperty"){const k=N.parameter;if(g.has(k))continue;g.add(k);let B;if(a.isIdentifier(k))B=k;else if(a.isAssignmentPattern(k)&&a.isIdentifier(k.left))B=k.left;else throw O.buildCodeFrameError("Parameter properties can not be destructuring patterns.");A.push(u.statement.ast`
          this.${a.cloneNode(B)} = ${a.cloneNode(B)}`),O.replaceWith(O.get("parameter")),p.registerBinding("param",O)}}(0,C.injectInitialization)(n,r,A)}};return{name:"transform-typescript",inherits:L.default,visitor:{Pattern:$,Identifier:$,RestElement:$,Program:{enter(r,n){const{file:A}=n;let p=null,O=null;const N=r.scope;if(S.GLOBAL_TYPES.has(N)||S.GLOBAL_TYPES.set(N,new Set),A.ast.comments)for(const t of A.ast.comments){const s=I.exec(t.value);s&&(s[1]?O=s[2]:p=s[2])}let k=p||D;k&&([k]=k.split("."));let B=O||l;B&&([B]=B.split("."));for(let t of r.get("body")){if(t.isImportDeclaration()){if(d.has(n.file.ast.program)||d.set(n.file.ast.program,!0),t.node.importKind==="type"){for(const y of t.node.specifiers)(0,S.registerGlobalType)(N,y.local.name);t.remove();continue}const s=new Set,b=t.node.specifiers.length,c=()=>b>0&&b===s.size;for(const y of t.node.specifiers)if(y.type==="ImportSpecifier"&&y.importKind==="type"){(0,S.registerGlobalType)(N,y.local.name);const _=t.scope.getBinding(y.local.name);_&&s.add(_.path)}if(x)d.set(r.node,!1);else{if(t.node.specifiers.length===0){d.set(r.node,!1);continue}for(const y of t.node.specifiers){const _=t.scope.getBinding(y.local.name);_&&!s.has(_.path)&&(q({binding:_,programPath:r,pragmaImportName:k,pragmaFragImportName:B})?s.add(_.path):d.set(r.node,!1))}}if(c()&&!x)t.remove();else for(const y of s)y.remove();continue}if(t.isExportDeclaration()&&(t=t.get("declaration")),t.isVariableDeclaration({declare:!0}))for(const s of Object.keys(t.getBindingIdentifiers()))(0,S.registerGlobalType)(N,s);else(t.isTSTypeAliasDeclaration()||t.isTSDeclareFunction()&&t.get("id").isIdentifier()||t.isTSInterfaceDeclaration()||t.isClassDeclaration({declare:!0})||t.isTSEnumDeclaration({declare:!0})||t.isTSModuleDeclaration({declare:!0})&&t.get("id").isIdentifier())&&(0,S.registerGlobalType)(N,t.node.id.name)}},exit(r){r.node.sourceType==="module"&&d.get(r.node)&&r.pushContainer("body",a.exportNamedDeclaration())}},ExportNamedDeclaration(r,n){if(d.has(n.file.ast.program)||d.set(n.file.ast.program,!0),r.node.exportKind==="type"){r.remove();return}if(r.node.source&&r.node.specifiers.length>0&&r.node.specifiers.every(A=>A.type==="ExportSpecifier"&&A.exportKind==="type")){r.remove();return}if(!r.node.source&&r.node.specifiers.length>0&&r.node.specifiers.every(A=>a.isExportSpecifier(A)&&(0,S.isGlobalType)(r,A.local.name))){r.remove();return}if(a.isTSModuleDeclaration(r.node.declaration)){const A=r.node.declaration,{id:p}=A;if(a.isIdentifier(p))if(r.scope.hasOwnBinding(p.name))r.replaceWith(A);else{const[O]=r.replaceWithMultiple([a.exportNamedDeclaration(a.variableDeclaration("let",[a.variableDeclarator(a.cloneNode(p))])),A]);r.scope.registerDeclaration(O)}}d.set(n.file.ast.program,!1)},ExportAllDeclaration(r){r.node.exportKind==="type"&&r.remove()},ExportSpecifier(r){(!r.parent.source&&(0,S.isGlobalType)(r,r.node.local.name)||r.node.exportKind==="type")&&r.remove()},ExportDefaultDeclaration(r,n){if(d.has(n.file.ast.program)||d.set(n.file.ast.program,!0),a.isIdentifier(r.node.declaration)&&(0,S.isGlobalType)(r,r.node.declaration.name)){r.remove();return}d.set(n.file.ast.program,!1)},TSDeclareFunction(r){m(r)},TSDeclareMethod(r){m(r)},VariableDeclaration(r){r.node.declare&&m(r)},VariableDeclarator({node:r}){r.definite&&(r.definite=null)},TSIndexSignature(r){r.remove()},ClassDeclaration(r){const{node:n}=r;n.declare&&m(r)},Class(r){const{node:n}=r;n.typeParameters&&(n.typeParameters=null),n.superTypeParameters&&(n.superTypeParameters=null),n.implements&&(n.implements=null),n.abstract&&(n.abstract=null),r.get("body.body").forEach(A=>{A.isClassMethod()||A.isClassPrivateMethod()?A.node.kind==="constructor"?M.constructor(A,r):M.method(A):(A.isClassProperty()||A.isClassPrivateProperty()||A.isClassAccessorProperty())&&M.field(A)})},Function(r){const{node:n}=r;n.typeParameters&&(n.typeParameters=null),n.returnType&&(n.returnType=null);const A=n.params;A.length>0&&a.isIdentifier(A[0],{name:"this"})&&A.shift()},TSModuleDeclaration(r){(0,F.default)(r,h)},TSInterfaceDeclaration(r){r.remove()},TSTypeAliasDeclaration(r){r.remove()},TSEnumDeclaration(r){E&&r.node.const?(0,j.default)(r,a):(0,w.default)(r,a)},TSImportEqualsDeclaration(r,n){const{id:A,moduleReference:p}=r.node;let O,N;a.isTSExternalModuleReference(p)?(R(r,n,`import ${A.name} = require(...);`,`import ${A.name} from '...';`," alongside Typescript's --allowSyntheticDefaultImports option"),O=a.callExpression(a.identifier("require"),[p.expression]),N="const"):(O=H(p),N="var"),r.replaceWith(a.variableDeclaration(N,[a.variableDeclarator(A,O)])),r.scope.registerDeclaration(r)},TSExportAssignment(r,n){R(r,n,"export = <value>;","export default <value>;"),r.replaceWith(u.statement.ast`module.exports = ${r.node.expression}`)},TSTypeAssertion(r){r.replaceWith(r.node.expression)},[`TSAsExpression${a.tsSatisfiesExpression?"|TSSatisfiesExpression":""}`](r){let{node:n}=r;do n=n.expression;while(a.isTSAsExpression(n)||a.isTSSatisfiesExpression!=null&&a.isTSSatisfiesExpression(n));r.replaceWith(n)},[i.types.tsInstantiationExpression?"TSNonNullExpression|TSInstantiationExpression":"TSNonNullExpression"](r){r.replaceWith(r.node.expression)},CallExpression(r){r.node.typeParameters=null},OptionalCallExpression(r){r.node.typeParameters=null},NewExpression(r){r.node.typeParameters=null},JSXOpeningElement(r){r.node.typeParameters=null},TaggedTemplateExpression(r){r.node.typeParameters=null}}};function H(r){return a.isTSQualifiedName(r)?a.memberExpression(H(r.left),r.right):r}function $({node:r}){r.typeAnnotation&&(r.typeAnnotation=null),a.isIdentifier(r)&&r.optional&&(r.optional=null)}function q({binding:r,programPath:n,pragmaImportName:A,pragmaFragImportName:p}){for(const N of r.referencePaths)if(!v(N))return!1;if(r.identifier.name!==A&&r.identifier.name!==p)return!0;let O=!1;return n.traverse({"JSXElement|JSXFragment"(N){O=!0,N.stop()}}),!O}}),we}var Ge={},Fe={},mt;function ss(){if(mt)return Fe;mt=1,Object.defineProperty(Fe,"__esModule",{value:!0}),Fe.transformDynamicImport=w;var e=oe(),L=Xe();const C=S=>e.template.expression.ast`require(${S})`,j=(S,F)=>e.types.callExpression(F.addHelper("interopRequireWildcard"),[C(S)]);function w(S,F,v){const d=F?C:j;S.replaceWith((0,L.buildDynamicImport)(S.node,!0,!1,g=>d(g,v)))}return Fe}var Te={},ht;function rs(){if(ht)return Te;ht=1,Object.defineProperty(Te,"__esModule",{value:!0}),Te.lazyImportsHook=void 0;var e=oe(),L=Xe();const C=j=>({name:"@babel/plugin-transform-modules-commonjs/lazy",version:"7.23.3",getWrapperPayload(w,S){if((0,L.isSideEffectImport)(S)||S.reexportAll)return null;if(j===!0)return/\./.test(w)?null:"lazy/function";if(Array.isArray(j))return j.indexOf(w)===-1?null:"lazy/function";if(typeof j=="function")return j(w)?"lazy/function":null},buildRequireWrapper(w,S,F,v){if(F==="lazy/function")return v?e.template.statement.ast`
        function ${w}() {
          const data = ${S};
          ${w} = function(){ return data; };
          return data;
        }
      `:!1},wrapReference(w,S){if(S==="lazy/function")return e.types.callExpression(w,[])}});return Te.lazyImportsHook=C,Te}var Ce={},yt;function ns(){if(yt)return Ce;yt=1,Object.defineProperty(Ce,"__esModule",{value:!0}),Ce.defineCommonJSHook=L,Ce.makeInvokers=j;const e="@babel/plugin-transform-modules-commonjs/customWrapperPlugin";function L(w,S){let F=w.get(e);F||w.set(e,F=[]),F.push(S)}function C(w,S){if(w)for(const F of w){const v=S(F);if(v!=null)return v}}function j(w){const S=w.get(e);return{getWrapperPayload(...F){return C(S,v=>v.getWrapperPayload==null?void 0:v.getWrapperPayload(...F))},wrapReference(...F){return C(S,v=>v.wrapReference==null?void 0:v.wrapReference(...F))},buildRequireWrapper(...F){return C(S,v=>v.buildRequireWrapper==null?void 0:v.buildRequireWrapper(...F))}}}return Ce}var bt;function is(){return bt||(bt=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0,Object.defineProperty(e,"defineCommonJSHook",{enumerable:!0,get:function(){return v.defineCommonJSHook}});var L=Ve(),C=Xe(),j=Ot(),w=oe(),S=ss(),F=rs(),v=ns();e.default=(0,L.declare)((d,g)=>{var m,R,i;d.assertVersion(7);const{strictNamespace:f=!1,mjsStrictNamespace:a=f,allowTopLevelThis:u,strict:I,strictMode:h,noInterop:D,importInterop:l,lazy:x=!1,allowCommonJSExports:E=!0,loose:P=!1}=g,M=(m=d.assumption("constantReexports"))!=null?m:P,H=(R=d.assumption("enumerableModuleMeta"))!=null?R:P,$=(i=d.assumption("noIncompleteNsImportDetection"))!=null?i:!1;if(typeof x!="boolean"&&typeof x!="function"&&(!Array.isArray(x)||!x.every(n=>typeof n=="string")))throw new Error(".lazy must be a boolean, array of strings, or a function");if(typeof f!="boolean")throw new Error(".strictNamespace must be a boolean, or undefined");if(typeof a!="boolean")throw new Error(".mjsStrictNamespace must be a boolean, or undefined");const q=n=>w.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${n}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `,r={ReferencedIdentifier(n){const A=n.node.name;if(A!=="module"&&A!=="exports")return;const p=n.scope.getBinding(A);this.scope.getBinding(A)!==p||n.parentPath.isObjectProperty({value:n.node})&&n.parentPath.parentPath.isObjectPattern()||n.parentPath.isAssignmentExpression({left:n.node})||n.isAssignmentExpression({left:n.node})||n.replaceWith(q(A))},UpdateExpression(n){const A=n.get("argument");if(!A.isIdentifier())return;const p=A.node.name;if(p!=="module"&&p!=="exports")return;const O=n.scope.getBinding(p);this.scope.getBinding(p)===O&&n.replaceWith(w.types.assignmentExpression(n.node.operator[0]+"=",A.node,q(p)))},AssignmentExpression(n){const A=n.get("left");if(A.isIdentifier()){const p=A.node.name;if(p!=="module"&&p!=="exports")return;const O=n.scope.getBinding(p);if(this.scope.getBinding(p)!==O)return;const k=n.get("right");k.replaceWith(w.types.sequenceExpression([k.node,q(p)]))}else if(A.isPattern()){const p=A.getOuterBindingIdentifiers(),O=Object.keys(p).filter(N=>N!=="module"&&N!=="exports"?!1:this.scope.getBinding(N)===n.scope.getBinding(N))[0];if(O){const N=n.get("right");N.replaceWith(w.types.sequenceExpression([N.node,q(O)]))}}}};return{name:"transform-modules-commonjs",pre(){this.file.set("@babel/plugin-transform-modules-*","commonjs"),x&&(0,v.defineCommonJSHook)(this.file,(0,F.lazyImportsHook)(x))},visitor:{["CallExpression"+(d.types.importExpression?"|ImportExpression":"")](n){if(!this.file.has("@babel/plugin-proposal-dynamic-import")||n.isCallExpression()&&!w.types.isImport(n.node.callee))return;let{scope:A}=n;do A.rename("require");while(A=A.parent);(0,S.transformDynamicImport)(n,D,this.file)},Program:{exit(n,A){if(!(0,C.isModule)(n))return;n.scope.rename("exports"),n.scope.rename("module"),n.scope.rename("require"),n.scope.rename("__filename"),n.scope.rename("__dirname"),E||((0,j.default)(n,new Set(["module","exports"]),!1),n.traverse(r,{scope:n.scope}));let p=(0,C.getModuleName)(this.file.opts,g);p&&(p=w.types.stringLiteral(p));const O=(0,v.makeInvokers)(this.file),{meta:N,headers:k}=(0,C.rewriteModuleStatementsAndPrepareHeader)(n,{exportName:"exports",constantReexports:M,enumerableModuleMeta:H,strict:I,strictMode:h,allowTopLevelThis:u,noInterop:D,importInterop:l,wrapReference:O.wrapReference,getWrapperPayload:O.getWrapperPayload,esNamespaceOnly:typeof A.filename=="string"&&/\.mjs$/.test(A.filename)?a:f,noIncompleteNsImportDetection:$,filename:this.file.opts.filename});for(const[t,s]of N.source){const b=w.types.callExpression(w.types.identifier("require"),[w.types.stringLiteral(t)]);let c;if((0,C.isSideEffectImport)(s)){if(x&&s.wrap==="function")throw new Error("Assertion failure");c=w.types.expressionStatement(b)}else{var B;const y=(0,C.wrapInterop)(n,b,s.interop)||b;if(s.wrap){const _=O.buildRequireWrapper(s.name,y,s.wrap,s.referenced);if(_===!1)continue;c=_}(B=c)!=null||(c=w.template.statement.ast`
                var ${s.name} = ${y};
              `)}c.loc=s.loc,k.push(c),k.push(...(0,C.buildNamespaceInitStatements)(N,s,M,O.wrapReference))}(0,C.ensureStatementsHoisted)(k),n.unshiftContainer("body",k),n.get("body").forEach(t=>{k.indexOf(t.node)!==-1&&t.isVariableDeclaration()&&t.scope.registerDeclaration(t)})}}}}})}(Ge)),Ge}var gt;function os(){if(gt)return _e;gt=1,Object.defineProperty(_e,"__esModule",{value:!0});var e=Ve(),L=ts();Rt();var C=is(),j=Bt();function w(R){return R&&R.__esModule?R:{default:R}}var S=w(L),F=w(C);const v=new j.OptionValidator("@babel/preset-typescript");function d(R={}){let{allowNamespaces:i=!0,jsxPragma:f,onlyRemoveTypeImports:a}=R;const u={ignoreExtensions:"ignoreExtensions",allowNamespaces:"allowNamespaces",disallowAmbiguousJSXLike:"disallowAmbiguousJSXLike",jsxPragma:"jsxPragma",jsxPragmaFrag:"jsxPragmaFrag",onlyRemoveTypeImports:"onlyRemoveTypeImports",optimizeConstEnums:"optimizeConstEnums",rewriteImportExtensions:"rewriteImportExtensions",allExtensions:"allExtensions",isTSX:"isTSX"},I=v.validateStringOption(u.jsxPragmaFrag,R.jsxPragmaFrag,"React.Fragment");{var h=v.validateBooleanOption(u.allExtensions,R.allExtensions,!1),D=v.validateBooleanOption(u.isTSX,R.isTSX,!1);D&&v.invariant(h,"isTSX:true requires allExtensions:true")}const l=v.validateBooleanOption(u.ignoreExtensions,R.ignoreExtensions,!1),x=v.validateBooleanOption(u.disallowAmbiguousJSXLike,R.disallowAmbiguousJSXLike,!1);x&&v.invariant(h,"disallowAmbiguousJSXLike:true requires allExtensions:true");const E=v.validateBooleanOption(u.optimizeConstEnums,R.optimizeConstEnums,!1),P=v.validateBooleanOption(u.rewriteImportExtensions,R.rewriteImportExtensions,!1),M={ignoreExtensions:l,allowNamespaces:i,disallowAmbiguousJSXLike:x,jsxPragma:f,jsxPragmaFrag:I,onlyRemoveTypeImports:a,optimizeConstEnums:E,rewriteImportExtensions:P};return M.allExtensions=h,M.isTSX=D,M}var g=e.declare(function({types:R}){return{name:"preset-typescript/plugin-rewrite-ts-imports",visitor:{"ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"({node:i}){const{source:f}=i;(R.isImportDeclaration(i)?i.importKind:i.exportKind)==="value"&&f&&/[\\/]/.test(f.value)&&(f.value=f.value.replace(/(\.[mc]?)ts$/,"$1js").replace(/\.tsx$/,".js"))}}}}),m=e.declarePreset((R,i)=>{R.assertVersion(7);const{allExtensions:f,ignoreExtensions:a,allowNamespaces:u,disallowAmbiguousJSXLike:I,isTSX:h,jsxPragma:D,jsxPragmaFrag:l,onlyRemoveTypeImports:x,optimizeConstEnums:E,rewriteImportExtensions:P}=d(i),M=q=>({allowDeclareFields:i.allowDeclareFields,allowNamespaces:u,disallowAmbiguousJSXLike:q,jsxPragma:D,jsxPragmaFrag:l,onlyRemoveTypeImports:x,optimizeConstEnums:E}),H=(q,r)=>[[S.default,Object.assign({isTSX:q},M(r))]];return{plugins:P?[g]:[],overrides:f||a?[{plugins:H(h,I)}]:[{test:/\.ts$/,plugins:H(!1,!1)},{test:/\.mts$/,sourceType:"module",plugins:H(!1,!0)},{test:/\.cts$/,sourceType:"unambiguous",plugins:[[F.default,{allowTopLevelThis:!0}],[S.default,M(!0)]]},{test:/\.tsx$/,plugins:H(!0,!1)}]}});return _e.default=m,_e}var as=os();const ls=kt(as),cs=`() => {
  const text: string = "Typed";
  return <h2>{text}</h2>;
}`,ds=()=>{const e=ge({initialCode:cs});return o.jsxs(We,{children:[o.jsx(He,{children:"TypeScript Support"}),o.jsxs(Y,{children:["We use babel to compile the code that user passes to the editor. By default, we apply only"," ",o.jsx("a",{href:"https://babeljs.io/docs/en/babel-preset-react",children:"@babel/preset-react"})," ","but you can import and use additional babel plugins. Do you want to support ",o.jsx("a",{href:"https://flow.org/",children:"Flow"}),"? Add"," ",o.jsx("a",{href:"@babel/preset-flow",children:"@babel/preset-flow"})," instead."]}),o.jsxs(Y,{children:["In this case, we have added"," ",o.jsx("a",{href:"https://babeljs.io/docs/en/babel-preset-typescript",children:"@babel/preset-typescript"})," ","to support TypeScript. This preset strips out all the TypeScript code but it does not validate types."]}),o.jsx(Ae,{children:o.jsx(ve,{...e.compilerProps,presets:[ls]})}),o.jsx(xe,{...e.editorProps,language:"tsx"}),o.jsx(pe,{...e.errorProps}),o.jsx(Ee,{children:"Usage"}),o.jsx(Y,{children:"The compiler component accepts an optional array of presets. You should also set the editor language to TSX to get a proper syntax highlighting."}),o.jsx(de,{children:`import {useView, Compiler, Editor, Error} from 'react-view';
import presetTypescript from '@babel/preset-typescript';

export default () => {
  const params = useView({
    initialCode: \`() => {
      const text: string = "Typed";
      return <h2>{text}</h2>;
    }\`,
    scope: {},
    onUpdate: console.log
  });

  return (
    <React.Fragment>
      <Compiler
        {...params.compilerProps}
        presets={[presetTypescript]}
      />
      <Editor {...params.editorProps} language="tsx" />
      <Error {...params.errorProps} />
    </React.Fragment>
  );
}`}),o.jsxs(Y,{children:[o.jsx("b",{children:"Note:"})," If you use react-view in the full mode (with the code-generation), we currently generate only plain JavaScript. The reason is that our examples simply do not need any type annotations since both TypeScript and Flow can infer 100% of them. So you can take the same output and copy paste it into a JS, TS or Flow codebase without any changes."]})]})},us=ds,hs={title:"useView"},ys=()=>o.jsx(At,{}),bs=()=>o.jsx(qt,{}),gs=()=>o.jsx(zt,{}),vs=()=>o.jsx(us,{});typeof window<"u"&&window.document&&window.document.createElement&&document.documentElement.setAttribute("data-storyloaded","");export{ys as basic,hs as default,gs as liveCodeOnly,bs as stateHook,vs as typescript};
